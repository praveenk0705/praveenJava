package apriori.core;

import java.util.ArrayList;
import java.util.List;

import apriori.sources.TransactionSource;
import apriori.gui.AprioriGui;

/**
 * This class represents the Apriori Algorithm.
 * 
 * @author Benjamin Bouvier
 * 
 */
public class AprioriAlgorithm {

	// The data source of the transactions. It's an object that can generate a
	// list of transactions.
	protected TransactionSource source;

	// The transactions generated by the source
	protected List<Itemset> transactions;

	// A link to the GUI, so as to log informations.
	protected AprioriGui gui;

	public AprioriAlgorithm(AprioriGui aprioriGui) {
		gui = aprioriGui;
	}

	/**
	 * Logs an information in the GUI.
	 * 
	 * @param s
	 *            String to be logged
	 */
	protected void log(String s) {
		gui.log(s);
	}

	/**
	 * Public setter for Source, used by the GUI, when the user clicks on one
	 * button.
	 * 
	 * Reinits all elements of the algorithm and saves the source.
	 * 
	 * @param transactionSource
	 *            A source of transactions.
	 */
	public void setSource(TransactionSource transactionSource) {
		LabelsMap.getInstance().clear();
		SupportMap.clear();
		source = transactionSource;
	}

	/**
	 * Generates the transactions from the source and logs them in the GUI.
	 * 
	 * @return
	 */
	public List<Itemset> getTransactions() {
		transactions = source.generate();
		log("The following transactions have been loaded: ");
		for (Itemset i : transactions) {
			log("\t> " + i);
		}
		return transactions;
	}

	/**
	 * The APriori Algorithm itself.
	 * 
	 * Frequent itemsets of size N are said here to belong to the level N.
	 * 
	 * The important steps of the algorithms are the following: 1) Computes
	 * support and keep frequent itemsets of size 1. 2) Continue to generate new
	 * itemsets while we have at least 2 different itemsets in the previous
	 * level of itemsets. 3) Once we computed all the frequent itemsets,
	 * generate all the rules.
	 * 
	 * The generation of new itemsets of size N+1 from the frequent itemsets of
	 * size N: - join step: let's take 2 different itemsets of size N with a
	 * common prefix of size N-1 and mix them to form an itemset I_NEW of size
	 * N+1. - prune step: check that all N-subsets of I_NEW are frequent
	 * (APriori principle). - if I_NEW is possible, checks its support value
	 * according to the support threshold.
	 * 
	 * @param support
	 *            the threshold value of support
	 * @param confidence
	 *            the threshold value of confidence
	 * @return A list of valid rules satisfying both support and confidence
	 *         thresholds.
	 */
	public List<Rule> run(int support, int confidence) {

		log("Launching A Priori algorithm with following parameters:");
		log("Support (absolute) min: " + support);
		log("Confidence min: " + confidence);

		double begin = System.currentTimeMillis(); // for performance analysis
													// only

		// let's register the transactions in the support map
		SupportMap.setup(transactions);

		// Step 1 of the algorithm: generate frequent 1-itemsets
		log("Computing frequents of size 1...");
		List<Itemset> previousLevel = new ArrayList<>();
		for (int i : LabelsMap.getInstance().getAllProducts()) {
			Itemset temp = new Itemset();
			temp.add(i);

			int itemSupport = temp.getRelativeSupport();
			log("\t> Item: " + temp + " (support: " + itemSupport + ")");

			if (itemSupport >= support) {
				log("\t\t=> This item is a frequent itemset of size 1.");
				previousLevel.add(temp);
			} else {
				log("\t\t=> This item isn't a frequent itemset of size 1.");
			}
		}

		// Step 2: generate frequent itemsets of higher size
		log("Computing frequents of higher size...");
		List<Itemset> allFrequents = new ArrayList<>(previousLevel);
		List<Itemset> nextLevel = null;
		int level = 1; // level is incremented just at the beginning of the
						// while loop
		while (previousLevel.size() >= 2) {
			log("\t> Computing frequents of size " + ++level);
			// level == N+1 is the size of itemsets we want to generate.

			// reinits next level elements. Next level elements are here
			// elements of the size N+1.
			nextLevel = new ArrayList<>();

			for (int i = 0, s = previousLevel.size(); i < s; ++i) {
				Itemset is1 = previousLevel.get(i); // is1 is one itemset of
													// size N-1
				for (int j = i + 1; j < s; ++j) {
					Itemset is2 = previousLevel.get(j); // is2 is another
														// itemset of size N-1
					// We need to know whether is1 and is2 share the same
					// prefix; for this, we put
					// all elements of is2 in a list and remove the last
					// element. The list is the prefix
					List<Integer> prefix = new ArrayList<>(is2);
					int last = prefix.remove(prefix.size() - 1);

					// The generated itemset is is1 with the last element of is2
					Itemset generated = new Itemset(is1);
					generated.add(last);
					if (!SupportMap.alreadyProcessed(generated)) {
						// first condition: checks that is1 share contains the
						// prefix, i.e. is1 and is2 have the same prefix
						// second condition: checks that all subsets of size N-1
						// of the generated element are frequent (APriori
						// principle)
						if (is1.containsAll(prefix)
								&& previousLevel.containsAll(generated
										.subsetWithoutOneElement())) {
							int generatedSupport = generated
									.getRelativeSupport();
							log("\t\t>> Generated itemset: " + generated
									+ " (support: " + generatedSupport + ")");
							// checks the support
							if (generatedSupport >= support) {
								log("\t\t\t>> Frequent itemset.");
								nextLevel.add(generated);
							} else {
								log("\t\t\t>> Not frequent.");
							}
						}
					}
				}
			}
			// All itemsets in nextLevel are frequent and of size N+1
			allFrequents.addAll(nextLevel);
			log("\t> All the frequent itemsets of size " + level
					+ " are the following: ");
			for (Itemset itemset : nextLevel) {
				log("\t\t>> " + itemset);
			}

			// The elements of size N+1 are the previous elements of the
			// generation of elements of size N+2
			previousLevel = nextLevel;
		}

		// generate all possible rules
		log("There are " + allFrequents.size() + " frequent itemsets");
		log("Generating rules...");
		int generatedRules = 0;
		List<Rule> ruleList = new ArrayList<>();
		for (Itemset frequent : allFrequents) {
			for (Rule r : frequent.generateRules()) {
				double ruleConfidence = r.confidence();
				log("\t> Considering the rule " + r + "...");
				if (ruleConfidence >= confidence) {
					++generatedRules;
					log("\t\t=> Rule kept.");
					ruleList.add(r);
				} else {
					log("\t\t=> Confidence too low.");
				}
			}
		}
		log(generatedRules + " rules have been generated.");

		log("Total duration: " + ((System.currentTimeMillis() - begin) / 1000.)
				+ "s");

		return ruleList;
	}
}
